<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Computer Science - 分类 -</title><link>https://nathanielgnef.github.io/categories/computer-science/</link><description>Computer Science - 分类 -</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>aquilah@aliyun.com (NathanielGnef)</managingEditor><webMaster>aquilah@aliyun.com (NathanielGnef)</webMaster><lastBuildDate>Thu, 28 Apr 2022 11:25:40 +0800</lastBuildDate><atom:link href="https://nathanielgnef.github.io/categories/computer-science/" rel="self" type="application/rss+xml"/><item><title>计算机随机数</title><link>https://nathanielgnef.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9A%8F%E6%9C%BA%E6%95%B0/</link><pubDate>Thu, 28 Apr 2022 11:25:40 +0800</pubDate><author>aquilah@aliyun.com (NathanielGnef)</author><guid>https://nathanielgnef.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid><description><![CDATA[<p>计算机中，随机数都是由<strong>随机数生成器(Random Number Generator)</strong> 生成的</p>
<h2 id="伪随机数pseudo-random-number">伪随机数(Pseudo-Random Number)</h2>
<h3 id="弱伪随机数">弱伪随机数</h3>
<p>特点是通过纯软件算法，按照一定的规律生成一个随机值。常用的方法是使用<strong>伪随机数生成器(PRNG)</strong></p>
<p><strong>伪随机数生成器(PRNG)</strong><br>
最基础的思想是<strong>均匀分布</strong>，最常用的算法就是<strong>线性同余法</strong><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>我们可以把这个伪随机数生成器看做是一个转换函数 <strong>f(x)</strong>，在生成的起始，我需要输入 <strong>x1</strong> ，当输入这个 <strong>x1</strong> 后，我们就可以通过转换函数得到第一个随机数<strong>f(x1)</strong>。 接下来，我们再把<strong>f(x1)</strong> 输入<strong>f(x)</strong> 到中，那么我们就可以得到第二个随机数<strong>f(x2)</strong>.一直下去，我们就可以得到一个<strong>伪随机序列</strong>。当然，上面的算法只是一个简单示例参考，实际的随机数生成程序还要复杂得多。有一点我们需要注意的是，对于这个伪随机数生成程序，我们发现主要我们初始<strong>x1</strong>输入的是一样的话，那么我们得到的随机序列就是相同的，而这个初始的<strong>x1</strong>其实就是我们的<strong>随机数种子(seed)</strong></p>
<p><strong>随机数种子(seed)</strong> 常用<strong>时间</strong>来生成，时间的变化终究有规律可循，所以弱伪随机数是有<strong>周期</strong>的</p>
<p>好的伪随机数生成器应具备以下特征：</p>
<ol>
<li>相同序列的概率非常低</li>
<li>符合统计学的平均性，比如所有数字出现概率应该相同，卡方检验应该能通过，超长游程长度概略应该非常小，自相关应该只有一个尖峰，任何长度的同一数字之后别的数字出现概率应该仍然是相等的等等</li>
<li>不应该能够从一段序列猜测出随机数发生器的工作状态或者下一个随机数</li>
<li>不应该从随机数发生器的状态能猜测出随机数发生器以前的工作状态</li>
</ol>
<p><strong>线性同余法</strong>：</p>
<ol>
<li>
<p>什么是线性同余法？<br>
线性同余法基于如下线性同余方程组：<br>
$ax+by=m$</p>
</li>
<li>
<p>用于产生均匀型伪随机数的线性同余生成器(与上面的方程符号没有对应关系)<br>
$x_n=(ax_{n-1}+b)mod(m)$</p>
</li>
<li>
<p>其中，a为&quot;乘数&quot;，b为&quot;增量&quot;，m为&quot;模数&quot;,x0为&quot;种子数&quot;
如果产生的是区间实在(0,1)之间的，则只需要每个数都除以m即可，即取<br>
$\xi_n=x_n/m$</p>
</li>
<li>
<p>线性同余法产生均匀型伪随机数需要注意什么？</p>
<ol>
<li>种子数是在计算时随机给出的</li>
<li>决定伪随机数质量的是其余的三个参数，即a,b,m决定生成伪随机数的质量(质量指的是伪随机数序列的周期性)</li>
<li>一般b不为0。如果b为零，线性同余法变成了<strong>乘同余法</strong><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></li>
</ol>
</li>
<li>
<p>高性能线性同余法参数取值要求？</p>
<ol>
<li>一般选取方法：乘数a满足$a=4p+1$；增量b满足$b=2q+1$。其中p，q为正整数</li>
<li>m值得话最好是选择大的，因为m值直接影响伪随机数序列的周期长短</li>
<li>a和b的值越大，产生的伪随机数越均匀</li>
<li>a和m如果互质，产生随机数效果比不互质好</li>
</ol>
</li>
</ol>
<h3 id="强伪随机数">强伪随机数</h3>
<p>顾名思义，该类随机数具有更强的随机数特性，能够满足<strong>随机性</strong>和<strong>不可推测特性</strong>。例如通过获取敲击键盘的数据作为随机数种子进而生成一组强伪随机数，因为击打键盘存在不确定性，所以生成的随机数也更接近与真正的随机数</p>
<h2 id="真随机数true-random-number">真随机数(TRUE Random Number)</h2>
<p>同时具备<strong>随机性</strong>、<strong>不可推测</strong>和<strong>不可重复</strong>这 3 个基本特点。真随机数的生成是基于<strong>物理现象</strong>完成的，例如掷骰子、抛硬币等等。</p>
<p><strong>硬件随机数生成器(HRNG)/真随机数生成器(TRNG)</strong><br>
通常是通过放大电路的热噪声来产生随机数</p>
<h2 id="准随机数quasi-random-number">准随机数(Quasi-Random Number)</h2>
<p><strong>准随机数发生器(QRNG)</strong> 产生高度均匀的单位超立方体样本</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>产生均匀型伪随机数的算法&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>也是最常用的均匀型伪随机数发生器&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item><item><title>进程和线程</title><link>https://nathanielgnef.github.io/posts/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</link><pubDate>Thu, 28 Apr 2022 11:09:10 +0800</pubDate><author>aquilah@aliyun.com (NathanielGnef)</author><guid>https://nathanielgnef.github.io/posts/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</guid><description><![CDATA[<h2 id="进程">进程</h2>
<ul>
<li>进程就是上下文切换之间的程序执行的部分。是运行中的程序的描述，也是对应于该段CPU执行时间的描述</li>
<li>在软件编码方面，我们说的进程，其实是稍不同的，编程语言中创建的进程是一个无限loop，对应的是tcb块。这个是操作系统进行调度的单位。所以和上面的cpu执行时间段还是不同的</li>
<li>进程，与之相关的东东有寻址空间，寄存器组，堆栈空间等。即不同的进程，这些东东都不同，从而能相互区别</li>
</ul>
<h2 id="线程">线程</h2>
<p>线程是共享了进程的上下文环境，的更为细小的CPU时间段。线程主要共享的是进程的地址空间</p>
]]></description></item><item><title>计算机编码</title><link>https://nathanielgnef.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/</link><pubDate>Thu, 28 Apr 2022 10:59:29 +0800</pubDate><author>aquilah@aliyun.com (NathanielGnef)</author><guid>https://nathanielgnef.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/</guid><description><![CDATA[<p>对编码规则的需求：<br>
在计算机中，所有的数据在存储和运算时都要使用二进制数表示，需要制定一套<strong>编码规则</strong>约定具体的二进制数代表具体的字符</p>
<h2 id="标准asciiamerican-standard-code-for-information-interchange0127-7bit">标准ASCII(American Standard Code for Information Interchange)(0~127 7bit)</h2>
<p>被 ISO (International Organization for Standardization)定为国际标准<br>
早期ASCII只能使用128个字符，表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符</p>
<p>规则：</p>
<ul>
<li>0~9&lt;A~Z&lt;a~z</li>
<li>同个字母的大写字母比小写字母要小32</li>
</ul>
<h2 id="扩展ascii码extended-ascii0255-8bit">扩展ASCII码(Extended ASCII)(0~255 8bit)</h2>
<p>欧洲人128个字符的字符集不够用，拓展到256个字符的字符集</p>
<h2 id="unicodeuniversal-multiple-octet-coded-character-setucs">Unicode(Universal Multiple-Octet Coded Character Set,UCS)</h2>
<p>它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的需求</p>
<ul>
<li>UTF-8(8位元，UCS Transfer Format)
是针对Unicode的一种可变长度字符编码,可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容</li>
<li>UTF-16(16位元)
UTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节（2字节）储存，但UTF-16却无法兼容于ASCII编码。</li>
</ul>
<h2 id="gb2312信息交换用汉字编码字符集基本集">GB2312(信息交换用汉字编码字符集·基本集)</h2>
<p>共收录 6763 个汉字，其中一级汉字 3755 个，二级汉字 3008 个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符</p>
<ul>
<li>对于人名、繁体字等方面出现的生僻字，GB 2312 不能处理，这导致了后来 GBK 及 GB 18030 汉字字符集的出现</li>
<li>对任意一个图形字符都采用两个字节表示</li>
</ul>
<h2 id="gbkchinese-internal-code-specification">GBK(Chinese Internal Code Specification)</h2>
<p>汉字内码扩展规范，K 为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母<br>
GBK 共收入 21886 个汉字和图形符号，包括：</p>
<ul>
<li>GB 2312 中的全部汉字、非汉字符号</li>
<li>BIG5 中的全部汉字</li>
<li>与 ISO 10646 相应的国家标准 GB 13000 中的其它 CJK 汉字，以上合计 20902 个汉字</li>
<li>其它汉字、部首、符号，共计 984 个</li>
</ul>
<p>GBK 向下与 GB 2312 完全兼容，向上支持 ISO 10646 国际标准<br>
GBK 采用双字节表示</p>
<h2 id="gb18030国家标准-gb-18030-2005信息技术中文编码字符集">GB18030(国家标准 GB 18030-2005《信息技术中文编码字符集》)</h2>
<p>GB 18030 与 GB 2312-1980 和 GBK 兼容，共收录汉字70244个</p>
<ul>
<li>与 UTF-8 相同，采用多字节编码，每个字可以由 1 个、2 个或 4 个字节组成</li>
<li>编码空间庞大，最多可定义 161 万个字符</li>
<li>支持中国国内少数民族的文字，不需要动用造字区</li>
<li>汉字收录范围包含繁体汉字以及日韩汉字</li>
</ul>
<p>GB 18030 编码是一二四字节变长编码</p>
]]></description></item></channel></rss>