<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>随机数 - 标签 -</title><link>https://nathanielgnef.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/</link><description>随机数 - 标签 -</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>aquilah@aliyun.com (NathanielGnef)</managingEditor><webMaster>aquilah@aliyun.com (NathanielGnef)</webMaster><lastBuildDate>Thu, 28 Apr 2022 11:25:40 +0800</lastBuildDate><atom:link href="https://nathanielgnef.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/" rel="self" type="application/rss+xml"/><item><title>计算机随机数</title><link>https://nathanielgnef.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9A%8F%E6%9C%BA%E6%95%B0/</link><pubDate>Thu, 28 Apr 2022 11:25:40 +0800</pubDate><author>aquilah@aliyun.com (NathanielGnef)</author><guid>https://nathanielgnef.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%9A%8F%E6%9C%BA%E6%95%B0/</guid><description><![CDATA[<p>计算机中，随机数都是由<strong>随机数生成器(Random Number Generator)</strong> 生成的</p>
<h2 id="伪随机数pseudo-random-number">伪随机数(Pseudo-Random Number)</h2>
<h3 id="弱伪随机数">弱伪随机数</h3>
<p>特点是通过纯软件算法，按照一定的规律生成一个随机值。常用的方法是使用<strong>伪随机数生成器(PRNG)</strong></p>
<p><strong>伪随机数生成器(PRNG)</strong><br>
最基础的思想是<strong>均匀分布</strong>，最常用的算法就是<strong>线性同余法</strong><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>我们可以把这个伪随机数生成器看做是一个转换函数 <strong>f(x)</strong>，在生成的起始，我需要输入 <strong>x1</strong> ，当输入这个 <strong>x1</strong> 后，我们就可以通过转换函数得到第一个随机数<strong>f(x1)</strong>。 接下来，我们再把<strong>f(x1)</strong> 输入<strong>f(x)</strong> 到中，那么我们就可以得到第二个随机数<strong>f(x2)</strong>.一直下去，我们就可以得到一个<strong>伪随机序列</strong>。当然，上面的算法只是一个简单示例参考，实际的随机数生成程序还要复杂得多。有一点我们需要注意的是，对于这个伪随机数生成程序，我们发现主要我们初始<strong>x1</strong>输入的是一样的话，那么我们得到的随机序列就是相同的，而这个初始的<strong>x1</strong>其实就是我们的<strong>随机数种子(seed)</strong></p>
<p><strong>随机数种子(seed)</strong> 常用<strong>时间</strong>来生成，时间的变化终究有规律可循，所以弱伪随机数是有<strong>周期</strong>的</p>
<p>好的伪随机数生成器应具备以下特征：</p>
<ol>
<li>相同序列的概率非常低</li>
<li>符合统计学的平均性，比如所有数字出现概率应该相同，卡方检验应该能通过，超长游程长度概略应该非常小，自相关应该只有一个尖峰，任何长度的同一数字之后别的数字出现概率应该仍然是相等的等等</li>
<li>不应该能够从一段序列猜测出随机数发生器的工作状态或者下一个随机数</li>
<li>不应该从随机数发生器的状态能猜测出随机数发生器以前的工作状态</li>
</ol>
<p><strong>线性同余法</strong>：</p>
<ol>
<li>
<p>什么是线性同余法？<br>
线性同余法基于如下线性同余方程组：<br>
$ax+by=m$</p>
</li>
<li>
<p>用于产生均匀型伪随机数的线性同余生成器(与上面的方程符号没有对应关系)<br>
$x_n=(ax_{n-1}+b)mod(m)$</p>
</li>
<li>
<p>其中，a为&quot;乘数&quot;，b为&quot;增量&quot;，m为&quot;模数&quot;,x0为&quot;种子数&quot;
如果产生的是区间实在(0,1)之间的，则只需要每个数都除以m即可，即取<br>
$\xi_n=x_n/m$</p>
</li>
<li>
<p>线性同余法产生均匀型伪随机数需要注意什么？</p>
<ol>
<li>种子数是在计算时随机给出的</li>
<li>决定伪随机数质量的是其余的三个参数，即a,b,m决定生成伪随机数的质量(质量指的是伪随机数序列的周期性)</li>
<li>一般b不为0。如果b为零，线性同余法变成了<strong>乘同余法</strong><sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></li>
</ol>
</li>
<li>
<p>高性能线性同余法参数取值要求？</p>
<ol>
<li>一般选取方法：乘数a满足$a=4p+1$；增量b满足$b=2q+1$。其中p，q为正整数</li>
<li>m值得话最好是选择大的，因为m值直接影响伪随机数序列的周期长短</li>
<li>a和b的值越大，产生的伪随机数越均匀</li>
<li>a和m如果互质，产生随机数效果比不互质好</li>
</ol>
</li>
</ol>
<h3 id="强伪随机数">强伪随机数</h3>
<p>顾名思义，该类随机数具有更强的随机数特性，能够满足<strong>随机性</strong>和<strong>不可推测特性</strong>。例如通过获取敲击键盘的数据作为随机数种子进而生成一组强伪随机数，因为击打键盘存在不确定性，所以生成的随机数也更接近与真正的随机数</p>
<h2 id="真随机数true-random-number">真随机数(TRUE Random Number)</h2>
<p>同时具备<strong>随机性</strong>、<strong>不可推测</strong>和<strong>不可重复</strong>这 3 个基本特点。真随机数的生成是基于<strong>物理现象</strong>完成的，例如掷骰子、抛硬币等等。</p>
<p><strong>硬件随机数生成器(HRNG)/真随机数生成器(TRNG)</strong><br>
通常是通过放大电路的热噪声来产生随机数</p>
<h2 id="准随机数quasi-random-number">准随机数(Quasi-Random Number)</h2>
<p><strong>准随机数发生器(QRNG)</strong> 产生高度均匀的单位超立方体样本</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>产生均匀型伪随机数的算法&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>也是最常用的均匀型伪随机数发生器&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></description></item></channel></rss>